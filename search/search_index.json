{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BassMap","text":"<p>BassMap is an intuitive Python Package that allows the user to display a variety of features on an iPyLeaflet and Folium map display. In addition the Landsat 8 Tools allows the user to create a variety of multispectral composites using local GeoTIFFs from Landsat 8 spectral bands. Try out the Landsat 8 Tools on Streamlit!</p> <ul> <li>GitHub</li> <li> <p>Documentation</p> </li> <li> <p>Free software: MIT license</p> </li> <li>Documentation: https://bassneel.github.io/bassmap</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Landsat 8 Tools</p> <ul> <li>Multispectral Composites<ul> <li>Create True Color Composite</li> <li>Create False Color (Buildings) Composite</li> <li>Create Color Infrared (Vegetation) Composite</li> <li>Create Healthy Vegetation Composite</li> </ul> </li> <li>Spectral Indicies<ul> <li>Create Normalized Difference Moisture Index (NDMI) Composite</li> <li>Create Normalized Difference Vegetation Index (NDVI) Composite</li> </ul> </li> </ul> </li> <li> <p>With IPyLeaflet (Mapomatic)</p> <ul> <li>Change basemap</li> <li>Display shapefiles</li> <li>Display GeoJSON files</li> <li>Display vector files</li> <li>Display Cloud Optimized GeoTIFFs</li> </ul> </li> <li>With Folium (Foliumatic)<ul> <li>Change basemap</li> <li>Display shapefiles</li> <li>Display GeoJSON files</li> <li>Display vector files</li> </ul> </li> </ul>"},{"location":"#demo","title":"Demo","text":""},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the giswqs/pypackage project template.</p>"},{"location":"Foliumatic/","title":"Foliumatic module","text":""},{"location":"Foliumatic/#bassmap.Foliumatic.Foliumatic","title":"<code> Foliumatic            (Map)         </code>","text":"Source code in <code>bassmap/Foliumatic.py</code> <pre><code>class Foliumatic(folium.Map):\n\n    def __init__(self):\n        self.map = folium.Map()\n\n    def __init__(self, lat=0, lon=0, zoom_start=2):\n        self.map = folium.Map(location=[lat, lon], zoom_start=zoom_start)\n\n    def add_tile_layers(self, tile_layers):\n        for tile_name, tile_url in tile_layers.items():\n            folium.TileLayer(tiles=tile_url, name=tile_name).add_to(self.map)\n\n        folium.LayerControl().add_to(self.map)\n\n        return self.map\n\n    def add_basemap(self, basemap_name):\n\"\"\"\n        Adds a basemap to the map using a predefined URL template for XYZ tile services.\n\n        Parameters:\n        basemap_name (str): The name of the basemap to add.\n        \"\"\"\n        basemap_urls = {\n            'OpenStreetMap': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n            'Mapbox Satellite': 'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=&lt;your-access-token&gt;',\n            'Esri.WorldImagery': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n            'OpenTopoMap': 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',\n            'Esri.NatGeoWorldMap': 'https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',\n            'CartoDB.Positron': 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n        }\n\n        url_template = basemap_urls.get(basemap_name)\n\n        if url_template is None:\n            raise ValueError(f'Unknown basemap name: {basemap_name}')\n\n        new_layer = folium.TileLayer(\n            tiles=url_template,\n            name=basemap_name,\n            attr=' '.join([basemap_name, 'Map data &amp;copy; &lt;a href=\"https://openstreetmap.org\"&gt;OpenStreetMap&lt;/a&gt; contributors']),\n            overlay=True,\n            control=True\n        )\n        self.add_child(new_layer)\n\n    def add_shp(self, data, **kwargs):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_geojson(self, geojson_data):\n\"\"\"\n        Adds a GeoJSON layer to the map.\n\n        Parameters:\n        geojson_data (str or dict): The GeoJSON file path, HTTP URL or dictionary to add to the map.\n        \"\"\"\n        if isinstance(geojson_data, str):\n            # Load GeoJSON from file or HTTP URL\n            if geojson_data.startswith(('http://', 'https://')):\n                response = requests.get(geojson_data)\n                geojson_layer = folium.GeoJson(data=response.content.decode())\n            else:\n                with open(geojson_data, 'r') as f:\n                    geojson_layer = folium.GeoJson(data=json.load(f))\n        elif isinstance(geojson_data, dict):\n            # Load GeoJSON from dictionary\n            geojson_layer = folium.GeoJson(data=geojson_data)\n        else:\n            raise ValueError('Invalid input format. Must be GeoJSON file path, HTTP URL or dictionary.')\n\n        geojson_layer.add_to(self)\n\n    def __init__(self, **kwargs):\n\"\"\"\n        Initializes a new instance of the Foliumatic class, which inherits from the folium.Map class.\n\n        Args:\n            **kwargs: Keyword arguments that can be passed to the folium.Map constructor.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.bounds = []\n\n    def add_vector(self, vector_data):\n\"\"\"\n        Adds vector data to the map.\n\n        The supported data types include file paths, URLs, GeoJSON dictionaries, and GeoDataFrames.\n\n        Args:\n            vector_data: The vector data to add to the map. Can be a file path, a URL, a GeoJSON dictionary, or a GeoDataFrame.\n\n        Raises:\n            ValueError: If the input data type is not supported or the shapefile is missing necessary files.\n        \"\"\"\n        if isinstance(vector_data, str):\n            # vector_data is a file path or a URL\n            if vector_data.startswith('http'):\n                # vector_data is a URL\n                r = requests.get(vector_data)\n                if zipfile.is_zipfile(io.BytesIO(r.content)):\n                    # vector_data is a zipped shapefile\n                    with zipfile.ZipFile(io.BytesIO(r.content)) as z:\n                        filenames = [y for y in sorted(z.namelist()) for ending in ['dbf', 'prj', 'shp', 'shx'] if y.endswith(ending) ]\n                        if not filenames:\n                            raise ValueError(\"Zip file does not contain .shp file.\")\n                        if len(filenames) &lt; 4:\n                            raise ValueError(\"Zip file does not contain all necessary files for a shapefile (shp, dbf, shx, prj).\")\n                        # Read the shapefile using geopandas and convert it to GeoJSON\n                        gdf = gpd.read_file(io.BytesIO(z.read(filenames[0])))\n                        geojson = gdf.to_crs(epsg='4326').to_json()\n                else:\n                    # vector_data is a GeoJSON URL\n                    geojson = requests.get(vector_data).json()\n            else:\n                # vector_data is a file path\n                if zipfile.is_zipfile(vector_data):\n                    # vector_data is a zipped shapefile\n                    with zipfile.ZipFile(vector_data) as z:\n                        filenames = [y for y in sorted(z.namelist()) for ending in ['dbf', 'prj', 'shp', 'shx'] if y.endswith(ending) ]\n                        if not filenames:\n                            raise ValueError(\"Zip file does not contain .shp file.\")\n                        if len(filenames) &lt; 4:\n                            raise ValueError(\"Zip file does not contain all necessary files for a shapefile (shp, dbf, shx, prj).\")\n                        # Read the shapefile using geopandas and convert it to GeoJSON\n                        gdf = gpd.read_file(io.BytesIO(z.read(filenames[0])))\n                        geojson = gdf.to_crs(epsg='4326').to_json()\n                else:\n                    # vector_data is a file path to a GeoJSON file or a shapefile\n                    gdf = gpd.read_file(vector_data)\n                    geojson = gdf.to_crs(epsg='4326').to_json()\n        elif isinstance(vector_data, dict):\n            # vector_data is a GeoJSON dictionary\n            geojson = vector_data\n        elif isinstance(vector_data, gpd.GeoDataFrame):\n            # vector_data is a GeoDataFrame\n            geojson = vector_data.to_crs(epsg='4326').to_json()\n        else:\n            raise ValueError(\"Invalid input data type. Supported data types include file paths, URLs, GeoJSON dictionaries, and GeoDataFrames.\")\n\n        folium.GeoJson(\n            geojson,\n            name=\"geojson\"\n        ).add_to(self)\n\n        folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"Foliumatic/#bassmap.Foliumatic.Foliumatic.__init__","title":"<code>__init__(self, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a new instance of the Foliumatic class, which inherits from the folium.Map class.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments that can be passed to the folium.Map constructor.</p> <code>{}</code> Source code in <code>bassmap/Foliumatic.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Initializes a new instance of the Foliumatic class, which inherits from the folium.Map class.\n\n    Args:\n        **kwargs: Keyword arguments that can be passed to the folium.Map constructor.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.bounds = []\n</code></pre>"},{"location":"Foliumatic/#bassmap.Foliumatic.Foliumatic.add_basemap","title":"<code>add_basemap(self, basemap_name)</code>","text":"<p>Adds a basemap to the map using a predefined URL template for XYZ tile services.</p> <p>basemap_name (str): The name of the basemap to add.</p> Source code in <code>bassmap/Foliumatic.py</code> <pre><code>def add_basemap(self, basemap_name):\n\"\"\"\n    Adds a basemap to the map using a predefined URL template for XYZ tile services.\n\n    Parameters:\n    basemap_name (str): The name of the basemap to add.\n    \"\"\"\n    basemap_urls = {\n        'OpenStreetMap': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n        'Mapbox Satellite': 'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=&lt;your-access-token&gt;',\n        'Esri.WorldImagery': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n        'OpenTopoMap': 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',\n        'Esri.NatGeoWorldMap': 'https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',\n        'CartoDB.Positron': 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n    }\n\n    url_template = basemap_urls.get(basemap_name)\n\n    if url_template is None:\n        raise ValueError(f'Unknown basemap name: {basemap_name}')\n\n    new_layer = folium.TileLayer(\n        tiles=url_template,\n        name=basemap_name,\n        attr=' '.join([basemap_name, 'Map data &amp;copy; &lt;a href=\"https://openstreetmap.org\"&gt;OpenStreetMap&lt;/a&gt; contributors']),\n        overlay=True,\n        control=True\n    )\n    self.add_child(new_layer)\n</code></pre>"},{"location":"Foliumatic/#bassmap.Foliumatic.Foliumatic.add_geojson","title":"<code>add_geojson(self, geojson_data)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>geojson_data (str or dict): The GeoJSON file path, HTTP URL or dictionary to add to the map.</p> Source code in <code>bassmap/Foliumatic.py</code> <pre><code>def add_geojson(self, geojson_data):\n\"\"\"\n    Adds a GeoJSON layer to the map.\n\n    Parameters:\n    geojson_data (str or dict): The GeoJSON file path, HTTP URL or dictionary to add to the map.\n    \"\"\"\n    if isinstance(geojson_data, str):\n        # Load GeoJSON from file or HTTP URL\n        if geojson_data.startswith(('http://', 'https://')):\n            response = requests.get(geojson_data)\n            geojson_layer = folium.GeoJson(data=response.content.decode())\n        else:\n            with open(geojson_data, 'r') as f:\n                geojson_layer = folium.GeoJson(data=json.load(f))\n    elif isinstance(geojson_data, dict):\n        # Load GeoJSON from dictionary\n        geojson_layer = folium.GeoJson(data=geojson_data)\n    else:\n        raise ValueError('Invalid input format. Must be GeoJSON file path, HTTP URL or dictionary.')\n\n    geojson_layer.add_to(self)\n</code></pre>"},{"location":"Foliumatic/#bassmap.Foliumatic.Foliumatic.add_vector","title":"<code>add_vector(self, vector_data)</code>","text":"<p>Adds vector data to the map.</p> <p>The supported data types include file paths, URLs, GeoJSON dictionaries, and GeoDataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>vector_data</code> <p>The vector data to add to the map. Can be a file path, a URL, a GeoJSON dictionary, or a GeoDataFrame.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input data type is not supported or the shapefile is missing necessary files.</p> Source code in <code>bassmap/Foliumatic.py</code> <pre><code>def add_vector(self, vector_data):\n\"\"\"\n    Adds vector data to the map.\n\n    The supported data types include file paths, URLs, GeoJSON dictionaries, and GeoDataFrames.\n\n    Args:\n        vector_data: The vector data to add to the map. Can be a file path, a URL, a GeoJSON dictionary, or a GeoDataFrame.\n\n    Raises:\n        ValueError: If the input data type is not supported or the shapefile is missing necessary files.\n    \"\"\"\n    if isinstance(vector_data, str):\n        # vector_data is a file path or a URL\n        if vector_data.startswith('http'):\n            # vector_data is a URL\n            r = requests.get(vector_data)\n            if zipfile.is_zipfile(io.BytesIO(r.content)):\n                # vector_data is a zipped shapefile\n                with zipfile.ZipFile(io.BytesIO(r.content)) as z:\n                    filenames = [y for y in sorted(z.namelist()) for ending in ['dbf', 'prj', 'shp', 'shx'] if y.endswith(ending) ]\n                    if not filenames:\n                        raise ValueError(\"Zip file does not contain .shp file.\")\n                    if len(filenames) &lt; 4:\n                        raise ValueError(\"Zip file does not contain all necessary files for a shapefile (shp, dbf, shx, prj).\")\n                    # Read the shapefile using geopandas and convert it to GeoJSON\n                    gdf = gpd.read_file(io.BytesIO(z.read(filenames[0])))\n                    geojson = gdf.to_crs(epsg='4326').to_json()\n            else:\n                # vector_data is a GeoJSON URL\n                geojson = requests.get(vector_data).json()\n        else:\n            # vector_data is a file path\n            if zipfile.is_zipfile(vector_data):\n                # vector_data is a zipped shapefile\n                with zipfile.ZipFile(vector_data) as z:\n                    filenames = [y for y in sorted(z.namelist()) for ending in ['dbf', 'prj', 'shp', 'shx'] if y.endswith(ending) ]\n                    if not filenames:\n                        raise ValueError(\"Zip file does not contain .shp file.\")\n                    if len(filenames) &lt; 4:\n                        raise ValueError(\"Zip file does not contain all necessary files for a shapefile (shp, dbf, shx, prj).\")\n                    # Read the shapefile using geopandas and convert it to GeoJSON\n                    gdf = gpd.read_file(io.BytesIO(z.read(filenames[0])))\n                    geojson = gdf.to_crs(epsg='4326').to_json()\n            else:\n                # vector_data is a file path to a GeoJSON file or a shapefile\n                gdf = gpd.read_file(vector_data)\n                geojson = gdf.to_crs(epsg='4326').to_json()\n    elif isinstance(vector_data, dict):\n        # vector_data is a GeoJSON dictionary\n        geojson = vector_data\n    elif isinstance(vector_data, gpd.GeoDataFrame):\n        # vector_data is a GeoDataFrame\n        geojson = vector_data.to_crs(epsg='4326').to_json()\n    else:\n        raise ValueError(\"Invalid input data type. Supported data types include file paths, URLs, GeoJSON dictionaries, and GeoDataFrames.\")\n\n    folium.GeoJson(\n        geojson,\n        name=\"geojson\"\n    ).add_to(self)\n\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"bassmap/","title":"BassMap module","text":"<p>Main module.</p>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic","title":"<code> Mapomatic            (Map)         </code>","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>class Mapomatic(Map):\n\n    def __init__(self, center=[20,0], **kwargs) -&gt; None:\n        if \"scroll_wheel_zoom\" not in kwargs:\n            kwargs[\"scroll_wheel_zoom\"] = True\n\n        super().__init__(center = center, **kwargs)\n\n    def add_marker(self, marker):\n        self.markers.append(marker)\n        self.add_layer(marker)\n\n    def add_image(self, url, position, size, opacity=1.0, layer_name=None):\n        image = ImageOverlay(\n            url=url,\n            bounds=[position, (position[0] + size[0], position[1] + size[1])],\n            opacity=opacity,\n            name=layer_name\n        )\n        self.add_layer(image)\n\n    def add_raster(self, url, name='Raster', fit_bounds=True, **kwargs):\n\"\"\"Adds a raster layer to the map.\n        Args:\n            url (str): The URL of the raster layer.\n            name (str, optional): The name of the raster layer. Defaults to 'Raster'.\n            fit_bounds (bool, optional): Whether to fit the map bounds to the raster layer. Defaults to True.\n        \"\"\"\n        import httpx\n\n        titiler_endpoint = \"https://titiler.xyz\"\n\n        r = httpx.get(\n            f\"{titiler_endpoint}/cog/info\",\n            params = {\n                \"url\": url,\n            }\n        ).json()\n\n        bounds = r[\"bounds\"]\n\n        r = httpx.get(\n            f\"{titiler_endpoint}/cog/tilejson.json\",\n            params = {\n                \"url\": url,\n            }\n        ).json()\n\n        tile = r[\"tiles\"][0]\n\n        self.add_tile_layer(url=tile, name=name, **kwargs)\n\n        if fit_bounds:\n            bbox = [[bounds[1], bounds[0]], [bounds[3], bounds[2]]]\n            self.fit_bounds(bbox)\n\n    def add_tile_layer(self, url, name, attribution = \"\", **kwargs):\n\"\"\"Adds a tile layer to the map.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str): The name of the tile layer\n            attribution (str, optional): The attribution of the tile layer. Defaults to **\n            \"\"\"\n        tile_layer = ipyleaflet.TileLayer(\n            url = url,\n            name = name,\n            attribution = attribution,\n            **kwargs\n        )\n        self.add_layer(tile_layer)\n\n    def add_layers_control(self, position=\"topright\", **kwargs):\n\"\"\"Adds a layers control to the map.\n\n        Args:\n            kwargs: Keyword arguments to pass to the layers control\n        \"\"\"\n        layers_control = ipyleaflet.LayersControl(position = position, **kwargs)\n        self.add_control(layers_control)\n\n    def add_fullscreen_control(self, position=\"topleft\"):\n\"\"\"Adds a fullscreen control to the map.\n\n        Args:\n            kwargs: Keyward arguments to pass to the layers control.\n        \"\"\"\n        fullscreen_control = ipyleaflet.FullScreenControl(position=position)\n        self.add_control(fullscreen_control)\n\n    def add_basemap(self, basemap_name, url_template):\n\"\"\"\n        Adds a basemap to the map using a URL template.\n\n        Parameters:\n        basemap_name (str): The name of the basemap to add.\n        url_template (str): The URL template to use for the new basemap layer. Must be \n            a valid XYZ tile service.\n        \"\"\"\n        # Remove the default OpenStreetMap basemap layer, if present\n        if len(self.layers) &gt; 1:\n            self.remove_layer(self.layers[0])\n\n        # Add the new basemap layer\n        new_layer = TileLayer(url=url_template, attribution=basemap_name)\n        self.add_layer(new_layer)\n\n    def add_shp(self, shp_path):\n\"\"\"\n        Adds a shapefile to the map. \n\n        Parameters:\n        shp_path (str): The file path or HTTP URL to the shapefile in a zip file.\n        \"\"\"\n        # If the path is an HTTP URL, download and unzip the shapefile\n        if shp_path.startswith('http'):\n            response = requests.get(shp_path)\n            with zipfile.ZipFile(io.BytesIO(response.content)) as zip_ref:\n                zip_ref.extractall()\n            shp_path = shp_path.split('/')[-1].split('.')[0] + '.shp'\n\n        # Read the shapefile using GeoPandas\n        gdf = gpd.read_file(shp_path)\n\n        # Convert the GeoDataFrame to a GeoJSON object\n        geojson = GeoJSON(data=gdf.__geo_interface__)\n\n        # Add the GeoJSON layer to the map\n        self.add_layer(geojson)\n\n        # Add a layer control to the map\n        control = LayersControl(position='topright')\n        self.add_control(control)\n\n    def add_geojson(self, geojson_path):\n\"\"\"\n        Adds a GeoJSON file to the map. \n\n        Parameters:\n        geojson_path (str or dict): The file path or dictionary object containing GeoJSON data.\n        \"\"\"\n        # If the path is an HTTP URL, download the GeoJSON file\n        if isinstance(geojson_path, str) and geojson_path.startswith('http'):\n            response = requests.get(geojson_path)\n            geojson_data = response.json()\n        # Otherwise, assume it's a file path or a dictionary object\n        else:\n            with open(geojson_path) as f:\n                geojson_data = json.load(f)\n\n        # Create a GeoJSON layer and add it to the map\n        geojson = GeoJSON(data=geojson_data)\n        self.add_layer(geojson)\n\n        # Add a layer control to the map\n        control = LayersControl(position='topright')\n        self.add_control(control)\n\n    def add_vector(self, vector_data):\n\"\"\"\n        Adds a vector data to the map. The vector data can be in any GeoPandas-supported\n        format, such as GeoJSON, shapefile, GeoDataFrame, etc.\n\n        Parameters:\n        vector_data (str or dict or GeoDataFrame): The vector data to add to the map. \n            Can be a file path or URL to the vector data, a dictionary object containing \n            GeoJSON data, or a GeoDataFrame.\n        \"\"\"\n        # If the vector data is a file path or URL, read it using GeoPandas\n        if isinstance(vector_data, str):\n            try:\n                gdf = gpd.read_file(vector_data)\n            except ValueError:\n                gdf = gpd.read_file(vector_data, encoding='utf-8')\n        # If the vector data is a dictionary object, create a GeoDataFrame\n        elif isinstance(vector_data, dict):\n            gdf = gpd.GeoDataFrame.from_features(vector_data['features'])\n        # If the vector data is already a GeoDataFrame, use it directly\n        elif isinstance(vector_data, gpd.GeoDataFrame):\n            gdf = vector_data\n        else:\n            raise ValueError('Invalid vector data format. Must be a file path or URL, a dictionary object containing GeoJSON data, or a GeoDataFrame.')\n\n        # Convert the GeoDataFrame to a GeoJSON object\n        geojson = GeoJSON(data=gdf.__geo_interface__)\n\n        # Add the GeoJSON layer to the map\n        self.add_layer(geojson)\n\n        # Add a layer control to the map\n        control = LayersControl(position='topright')\n        self.add_control(control)\n\n    def select_basemap(self, **kwargs):\n\"\"\"\n        Adds a basemap selector to the map instance.\n\n        Parameters:\n            self: bassmap Mapomatic: map instance called by user\n\n        Returns:\n            bassmap Mapomatic: displays drop down menu when called to the Mapomatic class\n        \"\"\"\n\n        output_widget = widgets.Output(layout = {'border': '1px solid white'})\n        output_widget.clear_output()\n\n        with output_widget:\n            display(HTML('''\n                &lt;style&gt;\n                    .widget-dropdown { background-color: black !important; }\n                    .widget-dropdown .widget-label { color: olive !important; }\n                &lt;/style&gt;\n            '''))\n\n        basemap_ctrl = WidgetControl(widget = output_widget, position='topright')\n        self.add_control(basemap_ctrl)\n\n        dropdown = widgets.Dropdown(\n            options = [\"OpenStreetMap\", \"ESRI Imagery\", \"OpenTopoMap\", \"NatGeo World Map\", \"Light Canvas\"], \n            value = None,\n            description = 'Basemap',\n            style = {'description_width': 'initial', 'button_width': '100px', 'button_color': 'olive', 'description_color': 'olive', 'background-color': 'olive'}\n        )\n\n        icon_html = '&lt;i class=\"fa fa-window-close\" aria-hidden=\"true\"&gt;&lt;/i&gt;'\n        close_button = widgets.ToggleButton(\n            value = True,\n            tooltip = \"Toggle basemap selector\",\n            description = 'Close',\n            icon = icon_html,\n            button_style = \"primary\",\n        )\n\n        close_button.style.button_color = \"white\"\n        close_button.style.font_weight = \"bold\"\n\n        close_button_icon = HTML(\n            '&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;'\n            '&lt;i class=\"fa fa-times\"&gt;&lt;/i&gt;'\n        )\n\n        widget_menu = widgets.VBox([close_button, dropdown])\n\n\n        with output_widget:\n            display(widget_menu)\n\n        def change_basemap(select):\n            if select[\"new\"] == \"OpenStreetMap\":\n                self.add_basemap(basemap_name= \"OpenStreetMap\", url_template=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\")\n\n            if select[\"new\"] == \"ESRI Imagery\":\n                self.add_basemap(basemap_name= \"Esri.WorldImagery\", url_template=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\")\n\n            if select[\"new\"] == \"OpenTopoMap\":\n                self.add_basemap(basemap_name= \"OpenTopoMap\", url_template=\"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\")\n\n            if select[\"new\"] == \"NatGeo World Map\":\n                self.add_basemap(basemap_name= \"Esri.NatGeoWorldMap\", url_template=\"https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}\")\n\n            if select[\"new\"] == \"Light Canvas\":\n                self.add_basemap(basemap_name= \"CartoDB.Positron\", url_template=\"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\")\n\n        dropdown.observe(change_basemap, \"value\")\n\n        def close_basemap(select):\n\n            if select[\"new\"] == True:\n                output_widget.clear_output()\n                with output_widget:\n                    display(widget_menu)\n\n            else:\n                output_widget.clear_output()\n                with output_widget:\n                    display(close_button)\n\n        close_button.observe(close_basemap, \"value\")\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_basemap","title":"<code>add_basemap(self, basemap_name, url_template)</code>","text":"<p>Adds a basemap to the map using a URL template.</p> <p>basemap_name (str): The name of the basemap to add. url_template (str): The URL template to use for the new basemap layer. Must be      a valid XYZ tile service.</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_basemap(self, basemap_name, url_template):\n\"\"\"\n    Adds a basemap to the map using a URL template.\n\n    Parameters:\n    basemap_name (str): The name of the basemap to add.\n    url_template (str): The URL template to use for the new basemap layer. Must be \n        a valid XYZ tile service.\n    \"\"\"\n    # Remove the default OpenStreetMap basemap layer, if present\n    if len(self.layers) &gt; 1:\n        self.remove_layer(self.layers[0])\n\n    # Add the new basemap layer\n    new_layer = TileLayer(url=url_template, attribution=basemap_name)\n    self.add_layer(new_layer)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_fullscreen_control","title":"<code>add_fullscreen_control(self, position='topleft')</code>","text":"<p>Adds a fullscreen control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Keyward arguments to pass to the layers control.</p> required Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_fullscreen_control(self, position=\"topleft\"):\n\"\"\"Adds a fullscreen control to the map.\n\n    Args:\n        kwargs: Keyward arguments to pass to the layers control.\n    \"\"\"\n    fullscreen_control = ipyleaflet.FullScreenControl(position=position)\n    self.add_control(fullscreen_control)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_geojson","title":"<code>add_geojson(self, geojson_path)</code>","text":"<p>Adds a GeoJSON file to the map. </p> <p>geojson_path (str or dict): The file path or dictionary object containing GeoJSON data.</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_geojson(self, geojson_path):\n\"\"\"\n    Adds a GeoJSON file to the map. \n\n    Parameters:\n    geojson_path (str or dict): The file path or dictionary object containing GeoJSON data.\n    \"\"\"\n    # If the path is an HTTP URL, download the GeoJSON file\n    if isinstance(geojson_path, str) and geojson_path.startswith('http'):\n        response = requests.get(geojson_path)\n        geojson_data = response.json()\n    # Otherwise, assume it's a file path or a dictionary object\n    else:\n        with open(geojson_path) as f:\n            geojson_data = json.load(f)\n\n    # Create a GeoJSON layer and add it to the map\n    geojson = GeoJSON(data=geojson_data)\n    self.add_layer(geojson)\n\n    # Add a layer control to the map\n    control = LayersControl(position='topright')\n    self.add_control(control)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_layers_control","title":"<code>add_layers_control(self, position='topright', **kwargs)</code>","text":"<p>Adds a layers control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Keyword arguments to pass to the layers control</p> <code>{}</code> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_layers_control(self, position=\"topright\", **kwargs):\n\"\"\"Adds a layers control to the map.\n\n    Args:\n        kwargs: Keyword arguments to pass to the layers control\n    \"\"\"\n    layers_control = ipyleaflet.LayersControl(position = position, **kwargs)\n    self.add_control(layers_control)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_raster","title":"<code>add_raster(self, url, name='Raster', fit_bounds=True, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the raster layer.</p> required <code>name</code> <code>str</code> <p>The name of the raster layer. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit the map bounds to the raster layer. Defaults to True.</p> <code>True</code> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_raster(self, url, name='Raster', fit_bounds=True, **kwargs):\n\"\"\"Adds a raster layer to the map.\n    Args:\n        url (str): The URL of the raster layer.\n        name (str, optional): The name of the raster layer. Defaults to 'Raster'.\n        fit_bounds (bool, optional): Whether to fit the map bounds to the raster layer. Defaults to True.\n    \"\"\"\n    import httpx\n\n    titiler_endpoint = \"https://titiler.xyz\"\n\n    r = httpx.get(\n        f\"{titiler_endpoint}/cog/info\",\n        params = {\n            \"url\": url,\n        }\n    ).json()\n\n    bounds = r[\"bounds\"]\n\n    r = httpx.get(\n        f\"{titiler_endpoint}/cog/tilejson.json\",\n        params = {\n            \"url\": url,\n        }\n    ).json()\n\n    tile = r[\"tiles\"][0]\n\n    self.add_tile_layer(url=tile, name=name, **kwargs)\n\n    if fit_bounds:\n        bbox = [[bounds[1], bounds[0]], [bounds[3], bounds[2]]]\n        self.fit_bounds(bbox)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_shp","title":"<code>add_shp(self, shp_path)</code>","text":"<p>Adds a shapefile to the map. </p> <p>shp_path (str): The file path or HTTP URL to the shapefile in a zip file.</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_shp(self, shp_path):\n\"\"\"\n    Adds a shapefile to the map. \n\n    Parameters:\n    shp_path (str): The file path or HTTP URL to the shapefile in a zip file.\n    \"\"\"\n    # If the path is an HTTP URL, download and unzip the shapefile\n    if shp_path.startswith('http'):\n        response = requests.get(shp_path)\n        with zipfile.ZipFile(io.BytesIO(response.content)) as zip_ref:\n            zip_ref.extractall()\n        shp_path = shp_path.split('/')[-1].split('.')[0] + '.shp'\n\n    # Read the shapefile using GeoPandas\n    gdf = gpd.read_file(shp_path)\n\n    # Convert the GeoDataFrame to a GeoJSON object\n    geojson = GeoJSON(data=gdf.__geo_interface__)\n\n    # Add the GeoJSON layer to the map\n    self.add_layer(geojson)\n\n    # Add a layer control to the map\n    control = LayersControl(position='topright')\n    self.add_control(control)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_tile_layer","title":"<code>add_tile_layer(self, url, name, attribution='', **kwargs)</code>","text":"<p>Adds a tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>The name of the tile layer</p> required <code>attribution</code> <code>str</code> <p>The attribution of the tile layer. Defaults to **</p> <code>''</code> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_tile_layer(self, url, name, attribution = \"\", **kwargs):\n\"\"\"Adds a tile layer to the map.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str): The name of the tile layer\n        attribution (str, optional): The attribution of the tile layer. Defaults to **\n        \"\"\"\n    tile_layer = ipyleaflet.TileLayer(\n        url = url,\n        name = name,\n        attribution = attribution,\n        **kwargs\n    )\n    self.add_layer(tile_layer)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.add_vector","title":"<code>add_vector(self, vector_data)</code>","text":"<p>Adds a vector data to the map. The vector data can be in any GeoPandas-supported format, such as GeoJSON, shapefile, GeoDataFrame, etc.</p> <p>vector_data (str or dict or GeoDataFrame): The vector data to add to the map.      Can be a file path or URL to the vector data, a dictionary object containing      GeoJSON data, or a GeoDataFrame.</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def add_vector(self, vector_data):\n\"\"\"\n    Adds a vector data to the map. The vector data can be in any GeoPandas-supported\n    format, such as GeoJSON, shapefile, GeoDataFrame, etc.\n\n    Parameters:\n    vector_data (str or dict or GeoDataFrame): The vector data to add to the map. \n        Can be a file path or URL to the vector data, a dictionary object containing \n        GeoJSON data, or a GeoDataFrame.\n    \"\"\"\n    # If the vector data is a file path or URL, read it using GeoPandas\n    if isinstance(vector_data, str):\n        try:\n            gdf = gpd.read_file(vector_data)\n        except ValueError:\n            gdf = gpd.read_file(vector_data, encoding='utf-8')\n    # If the vector data is a dictionary object, create a GeoDataFrame\n    elif isinstance(vector_data, dict):\n        gdf = gpd.GeoDataFrame.from_features(vector_data['features'])\n    # If the vector data is already a GeoDataFrame, use it directly\n    elif isinstance(vector_data, gpd.GeoDataFrame):\n        gdf = vector_data\n    else:\n        raise ValueError('Invalid vector data format. Must be a file path or URL, a dictionary object containing GeoJSON data, or a GeoDataFrame.')\n\n    # Convert the GeoDataFrame to a GeoJSON object\n    geojson = GeoJSON(data=gdf.__geo_interface__)\n\n    # Add the GeoJSON layer to the map\n    self.add_layer(geojson)\n\n    # Add a layer control to the map\n    control = LayersControl(position='topright')\n    self.add_control(control)\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.Mapomatic.select_basemap","title":"<code>select_basemap(self, **kwargs)</code>","text":"<p>Adds a basemap selector to the map instance.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>bassmap Mapomatic: map instance called by user</p> required <p>Returns:</p> Type Description <code>bassmap Mapomatic</code> <p>displays drop down menu when called to the Mapomatic class</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def select_basemap(self, **kwargs):\n\"\"\"\n    Adds a basemap selector to the map instance.\n\n    Parameters:\n        self: bassmap Mapomatic: map instance called by user\n\n    Returns:\n        bassmap Mapomatic: displays drop down menu when called to the Mapomatic class\n    \"\"\"\n\n    output_widget = widgets.Output(layout = {'border': '1px solid white'})\n    output_widget.clear_output()\n\n    with output_widget:\n        display(HTML('''\n            &lt;style&gt;\n                .widget-dropdown { background-color: black !important; }\n                .widget-dropdown .widget-label { color: olive !important; }\n            &lt;/style&gt;\n        '''))\n\n    basemap_ctrl = WidgetControl(widget = output_widget, position='topright')\n    self.add_control(basemap_ctrl)\n\n    dropdown = widgets.Dropdown(\n        options = [\"OpenStreetMap\", \"ESRI Imagery\", \"OpenTopoMap\", \"NatGeo World Map\", \"Light Canvas\"], \n        value = None,\n        description = 'Basemap',\n        style = {'description_width': 'initial', 'button_width': '100px', 'button_color': 'olive', 'description_color': 'olive', 'background-color': 'olive'}\n    )\n\n    icon_html = '&lt;i class=\"fa fa-window-close\" aria-hidden=\"true\"&gt;&lt;/i&gt;'\n    close_button = widgets.ToggleButton(\n        value = True,\n        tooltip = \"Toggle basemap selector\",\n        description = 'Close',\n        icon = icon_html,\n        button_style = \"primary\",\n    )\n\n    close_button.style.button_color = \"white\"\n    close_button.style.font_weight = \"bold\"\n\n    close_button_icon = HTML(\n        '&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;'\n        '&lt;i class=\"fa fa-times\"&gt;&lt;/i&gt;'\n    )\n\n    widget_menu = widgets.VBox([close_button, dropdown])\n\n\n    with output_widget:\n        display(widget_menu)\n\n    def change_basemap(select):\n        if select[\"new\"] == \"OpenStreetMap\":\n            self.add_basemap(basemap_name= \"OpenStreetMap\", url_template=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\")\n\n        if select[\"new\"] == \"ESRI Imagery\":\n            self.add_basemap(basemap_name= \"Esri.WorldImagery\", url_template=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\")\n\n        if select[\"new\"] == \"OpenTopoMap\":\n            self.add_basemap(basemap_name= \"OpenTopoMap\", url_template=\"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\")\n\n        if select[\"new\"] == \"NatGeo World Map\":\n            self.add_basemap(basemap_name= \"Esri.NatGeoWorldMap\", url_template=\"https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}\")\n\n        if select[\"new\"] == \"Light Canvas\":\n            self.add_basemap(basemap_name= \"CartoDB.Positron\", url_template=\"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\")\n\n    dropdown.observe(change_basemap, \"value\")\n\n    def close_basemap(select):\n\n        if select[\"new\"] == True:\n            output_widget.clear_output()\n            with output_widget:\n                display(widget_menu)\n\n        else:\n            output_widget.clear_output()\n            with output_widget:\n                display(close_button)\n\n    close_button.observe(close_basemap, \"value\")\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.generate_input_points","title":"<code>generate_input_points()</code>","text":"<p>Input name and either generate random point or input coordinates to shapefile and display on map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the location.</p> required <code>lat</code> <code>int</code> <p>The latitude value</p> required <code>lon</code> <code>int</code> <p>The longitude value</p> required <code>generate_random</code> <code>int</code> <p>Whether to generate random coordinates or use custom</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Latitude must be between -90 and 90 degrees</p> <code>ValueError</code> <p>Longitude must be between -180 and 180 degrees</p> Source code in <code>bassmap/bassmap.py</code> <pre><code>def generate_input_points():\n\"\"\"Input name and either generate random point or input coordinates to shapefile and display on map.\n\n    Args:\n        name (): Name of the location.\n        lat (int, optional): The latitude value\n        lon (int, optional): The longitude value\n        generate_random (int, optional): Whether to generate random coordinates or use custom\n    Raises:\n        ValueError: Latitude must be between -90 and 90 degrees\n        ValueError: Longitude must be between -180 and 180 degrees\n    \"\"\"\n\n    while True:\n        name = input(\"Enter location name (or 'q' to finish): \")\n\n        if name == 'q':\n            break\n\n        generate_random = input(\"Generate random point? (y/n): \")\n        if generate_random.lower() == \"y\":\n\n            lat = random.uniform(-90, 90)\n            lon = random.uniform(-180, 180)\n            locations[name] = {'lat': lat, 'lon': lon}\n            print(f\"The location {name} is located at ({lat}, {lon}).\\n\")\n        else:\n            lat = input(\"Enter latitude: \")\n            lon = input(\"Enter longitude: \")\n\n            try:\n                lat = float(lat)\n                lon = float(lon)\n\n                if lat &lt; -90 or lat &gt; 90:\n                    raise ValueError(\"Latitude must be between -90 and 90 degrees\")\n                if lon &lt; -180 or lon &gt; 180:\n                    raise ValueError(\"Longitude must be between -180 and 180 degrees\")\n\n                locations[name] = {'lat': lat, 'lon': lon}\n\n                print(f\"The location {name} is located at ({lat}, {lon}).\\n\")\n\n            except ValueError as e:\n                print(f\"Invalid input: {e}\")\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_NDVI","title":"<code>get_NDVI(red_band, nir_band, georef)</code>","text":"<p>Calculates the Normalized Difference Vegetation Index (NDVI) from Red and Near Infrared (NIR) bands.</p> <p>Parameters:</p> Name Type Description Default <code>red_band</code> <code>numpy.ndarray</code> <p>A 2D or 3D array containing the Red band data.</p> required <code>nir_band</code> <code>numpy.ndarray</code> <p>A 2D or 3D array containing the Near Infrared band data.</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created NDVI file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p> <p>red_band = gdal.Open('path/to/red_band.tif').ReadAsArray() nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_NDVI--generate-an-ndvi-composite-image-and-download-it","title":"Generate an NDVI composite image and download it","text":"<p>ndvi_path = get_NDVI(red_band, nir_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_NDVI--download-the-file-at-ndvi_path","title":"Download the file at ndvi_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_NDVI(red_band, nir_band, georef):\n\"\"\"\n    Calculates the Normalized Difference Vegetation Index (NDVI) from Red and Near Infrared (NIR) bands.\n\n    Args:\n        red_band (numpy.ndarray): A 2D or 3D array containing the Red band data.\n        nir_band (numpy.ndarray): A 2D or 3D array containing the Near Infrared band data.\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created NDVI file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Examples:\n        red_band = gdal.Open('path/to/red_band.tif').ReadAsArray()\n        nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate an NDVI composite image and download it\n        ndvi_path = get_NDVI(red_band, nir_band, georef)\n        # Download the file at ndvi_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Scale the input bands to the range of 0-255\n    red_band = (red_band / 65535.0) * 255.0\n    nir_band = (nir_band / 65535.0) * 255.0\n\n    # Calculate the NDVI from the NIR and Red bands\n    ndvi = np.empty_like(nir_band, dtype=np.float32)\n    ndvi.fill(np.nan)\n    valid = np.logical_and(red_band != 0, nir_band != 0)\n    ndvi[valid] = (nir_band[valid] - red_band[valid]) / (nir_band[valid] + red_band[valid])\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the NDVI array to it\n    ndvi_path = os.path.join(tmp_dir.name, 'ndvi_composite.tif')\n    ndvi_ds = driver.Create(ndvi_path, xsize, ysize, 1, gdal.GDT_Float32)\n\n    if ndvi_ds is not None:\n        ndvi_ds.SetProjection(proj)\n        ndvi_ds.SetGeoTransform(geotrans)\n        ndvi_ds.GetRasterBand(1).WriteArray(ndvi)\n        ndvi_ds.FlushCache()\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return ndvi_path\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_color_infrared","title":"<code>get_color_infrared(nir_band, red_band, green_band, georef)</code>","text":"<p>Combines a near-infrared band, red band, and green band into a single 3-band image, where the near-infrared band is displayed as red, the red band is displayed as green, and the green band is displayed as blue. This produces a color infrared image that accentuates the buildings in the scene.</p> <p>Parameters:</p> Name Type Description Default <code>nir_band</code> <code>numpy array</code> <p>A 2D numpy array representing a near-infrared band</p> required <code>red_band</code> <code>numpy array</code> <p>A 2D numpy array representing a red band</p> required <code>green_band</code> <code>numpy array</code> <p>A 2D numpy array representing a green band</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created color infrared file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p>"},{"location":"bassmap/#bassmap.bassmap.get_color_infrared--load-the-input-bands-as-numpy-arrays","title":"Load the input bands as numpy arrays","text":"<p>nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray() red_band = gdal.Open('path/to/red_band.tif').ReadAsArray() green_band = gdal.Open('path/to/green_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_color_infrared--generate-a-color-infrared-composite-image-and-download-it","title":"Generate a color infrared composite image and download it","text":"<p>color_infrared_path = get_color_infrared(nir_band, red_band, green_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_color_infrared--download-the-file-at-color_infrared_path","title":"Download the file at color_infrared_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_color_infrared(nir_band, red_band, green_band, georef):\n\n\"\"\"\n    Combines a near-infrared band, red band, and green band into a single 3-band image,\n    where the near-infrared band is displayed as red, the red band is displayed as green,\n    and the green band is displayed as blue. This produces a color infrared image that\n    accentuates the buildings in the scene.\n\n    Args:\n        nir_band (numpy array): A 2D numpy array representing a near-infrared band\n        red_band (numpy array): A 2D numpy array representing a red band\n        green_band (numpy array): A 2D numpy array representing a green band\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created color infrared file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Example:\n        # Load the input bands as numpy arrays\n        nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray()\n        red_band = gdal.Open('path/to/red_band.tif').ReadAsArray()\n        green_band = gdal.Open('path/to/green_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate a color infrared composite image and download it\n        color_infrared_path = get_color_infrared(nir_band, red_band, green_band, georef)\n        # Download the file at color_infrared_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Combine the three bands into a single 3D array with 3 bands\n    color_infrared = np.array([nir_band, red_band, green_band], dtype=np.uint16)\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the NDVI array to it\n    color_infrared_path = os.path.join(tmp_dir.name, 'color_infrared_comp.tif')\n    color_infrared_ds = driver.Create(color_infrared_path, xsize, ysize, 3, gdal.GDT_Float32)\n\n    if color_infrared_ds is not None:\n        color_infrared_ds.SetProjection(proj)\n        color_infrared_ds.SetGeoTransform(geotrans)\n        color_infrared_ds.GetRasterBand(1).WriteArray(color_infrared[0])\n        color_infrared_ds.GetRasterBand(2).WriteArray(color_infrared[1])\n        color_infrared_ds.GetRasterBand(3).WriteArray(color_infrared[2])\n        color_infrared_ds.FlushCache()\n\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return color_infrared_path\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_false_color","title":"<code>get_false_color(swir2_band, swir_band, red_band, georef)</code>","text":"<p>Combines a short wave infrared 2 band, a short wave infrared band, and red band into a single 3-band image, where the a short wave infrared 2 band is displayed as red, the a short wave infrared band is displayed as green, and the red band is displayed as blue. This produces a false-color image that accentuates the vegetation in the scene.</p> <p>Parameters:</p> Name Type Description Default <code>swir2_band</code> <code>numpy array</code> <p>A 2D numpy array representing a short wave infrared 2 band</p> required <code>swir_band</code> <code>numpy array</code> <p>A 2D numpy array representing a short wave infrared band</p> required <code>red_band</code> <code>numpy array</code> <p>A 2D numpy array representing a red band</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created false-color file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p>"},{"location":"bassmap/#bassmap.bassmap.get_false_color--load-the-input-bands-as-numpy-arrays","title":"Load the input bands as numpy arrays","text":"<p>swir2_band = gdal.Open('path/to/swir2_band.tif').ReadAsArray() swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray() red_band = gdal.Open('path/to/red_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_false_color--generate-a-false-color-composite-image-and-download-it","title":"Generate a false-color composite image and download it","text":"<p>false_color_path = false_color_path(swir2_band, swir_band, red_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_false_color--download-the-file-at-false_color_path","title":"Download the file at false_color_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_false_color(swir2_band, swir_band, red_band, georef):\n\n\"\"\"\n    Combines a short wave infrared 2 band, a short wave infrared band, and red band into a single 3-band image,\n    where the a short wave infrared 2 band is displayed as red, the a short wave infrared band is displayed as green,\n    and the red band is displayed as blue. This produces a false-color image that\n    accentuates the vegetation in the scene.\n\n    Args:\n        swir2_band (numpy array): A 2D numpy array representing a short wave infrared 2 band\n        swir_band (numpy array): A 2D numpy array representing a short wave infrared band\n        red_band (numpy array): A 2D numpy array representing a red band\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created false-color file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Example:\n        # Load the input bands as numpy arrays\n        swir2_band = gdal.Open('path/to/swir2_band.tif').ReadAsArray()\n        swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray()\n        red_band = gdal.Open('path/to/red_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate a false-color composite image and download it\n        false_color_path = false_color_path(swir2_band, swir_band, red_band, georef)\n        # Download the file at false_color_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Combine the three bands into a single 3D array with 3 bands\n    false_color = np.array([swir2_band, swir_band, red_band], dtype=np.uint16)\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the NDVI array to it\n    false_color_path = os.path.join(tmp_dir.name, 'false_color_comp.tif')\n    false_color_ds = driver.Create(false_color_path, xsize, ysize, 3, gdal.GDT_Float32)\n\n    if false_color_ds is not None:\n        false_color_ds.SetProjection(proj)\n        false_color_ds.SetGeoTransform(geotrans)\n        false_color_ds.GetRasterBand(1).WriteArray(false_color[0])\n        false_color_ds.GetRasterBand(2).WriteArray(false_color[1])\n        false_color_ds.GetRasterBand(3).WriteArray(false_color[2])\n        false_color_ds.FlushCache()\n\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return false_color_path\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_health_veg","title":"<code>get_health_veg(nir_band, swir_band, blue_band, georef)</code>","text":"<p>Combines a near infrared band, a short wave infrared band, and blue band into a single 3-band image, where the a near infrared band is displayed as red, the a short wave infrared band is displayed as green, and the blue band is displayed as blue. This produces a false-color image that accentuates the healthy vegetation in the scene.</p> <p>Parameters:</p> Name Type Description Default <code>nir_band</code> <code>numpy array</code> <p>A 2D numpy array representing a near infrared band</p> required <code>swir_band</code> <code>numpy array</code> <p>A 2D numpy array representing a short wave infrared band</p> required <code>blue_band</code> <code>numpy array</code> <p>A 2D numpy array representing a blue band</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created healthy vegetation file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p>"},{"location":"bassmap/#bassmap.bassmap.get_health_veg--load-the-input-bands-as-numpy-arrays","title":"Load the input bands as numpy arrays","text":"<p>nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray() swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray() blue_band = gdal.Open('path/to/blue_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_health_veg--generate-a-healthy-vegetation-composite-image-and-download-it","title":"Generate a healthy vegetation composite image and download it","text":"<p>healthy_veg_path = get_health_veg(nir_band, swir_band, blue_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_health_veg--download-the-file-at-healthy_veg_path","title":"Download the file at healthy_veg_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_health_veg(nir_band, swir_band, blue_band, georef):\n\n\"\"\"\n    Combines a near infrared band, a short wave infrared band, and blue band into a single 3-band image,\n    where the a near infrared band is displayed as red, the a short wave infrared band is displayed as green,\n    and the blue band is displayed as blue. This produces a false-color image that\n    accentuates the healthy vegetation in the scene.\n\n    Args:\n        nir_band (numpy array): A 2D numpy array representing a near infrared band\n        swir_band (numpy array): A 2D numpy array representing a short wave infrared band\n        blue_band (numpy array): A 2D numpy array representing a blue band\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created healthy vegetation file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Example:\n        # Load the input bands as numpy arrays\n        nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray()\n        swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray()\n        blue_band = gdal.Open('path/to/blue_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate a healthy vegetation composite image and download it\n        healthy_veg_path = get_health_veg(nir_band, swir_band, blue_band, georef)\n        # Download the file at healthy_veg_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Combine the three bands into a single 3D array with 3 bands\n    healthy_veg = np.array([nir_band, swir_band, blue_band], dtype=np.uint16)\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the composite array to it\n    healthy_veg_ds = driver.Create('/tmp/healthy_veg_comp.tif', xsize, ysize, 3, gdal.GDT_UInt16)\n\n    # Create a new TIFF file and write the NDVI array to it\n    healthy_veg_path = os.path.join(tmp_dir.name, 'healthy_veg_comp.tif')\n    healthy_veg_ds = driver.Create(healthy_veg_path, xsize, ysize, 3, gdal.GDT_Float32)\n\n    if healthy_veg_ds is not None:\n        healthy_veg_ds.SetProjection(proj)\n        healthy_veg_ds.SetGeoTransform(geotrans)\n        healthy_veg_ds.GetRasterBand(1).WriteArray(healthy_veg[0])\n        healthy_veg_ds.GetRasterBand(2).WriteArray(healthy_veg[1])\n        healthy_veg_ds.GetRasterBand(3).WriteArray(healthy_veg[2])\n        healthy_veg_ds.FlushCache()\n\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return healthy_veg_path\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_ndmi","title":"<code>get_ndmi(nir_band, swir_band, georef)</code>","text":"<p>Calculates the Normalized Difference Moisture Index (NDMI) from Near Infrared (NIR) and Shortwave Infrared (SWIR) bands.</p> <p>Parameters:</p> Name Type Description Default <code>nir_band</code> <code>numpy.ndarray</code> <p>A 2D or 3D array containing the Near Infrared band data.</p> required <code>swir_band</code> <code>numpy.ndarray</code> <p>A 2D or 3D array containing the Shortwave Infrared band data.</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created NDMI file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p> <p>nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray() swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_ndmi--generate-an-ndmi-composite-image-and-download-it","title":"Generate an NDMI composite image and download it","text":"<p>ndmi_path = get_NDMI(red_band, nir_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_ndmi--download-the-file-at-ndvi_path","title":"Download the file at ndvi_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_ndmi(nir_band, swir_band, georef):\n\n\"\"\"\n    Calculates the Normalized Difference Moisture Index (NDMI) from Near Infrared (NIR) and Shortwave Infrared (SWIR) bands.\n\n    Args:\n        nir_band (numpy.ndarray): A 2D or 3D array containing the Near Infrared band data.\n        swir_band (numpy.ndarray): A 2D or 3D array containing the Shortwave Infrared band data.\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created NDMI file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Examples:\n        nir_band = gdal.Open('path/to/nir_band.tif').ReadAsArray()\n        swir_band = gdal.Open('path/to/swir_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate an NDMI composite image and download it\n        ndmi_path = get_NDMI(red_band, nir_band, georef)\n        # Download the file at ndvi_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Scale the input bands to the range of 0-255\n    nir_band = (nir_band / 65535.0) * 255.0\n    swir_band = (swir_band / 65535.0) * 255.0\n\n    # Calculate the NDMI from the NIR and SWIR bands\n    ndmi = np.empty_like(nir_band, dtype=np.float32)\n    ndmi.fill(np.nan)\n    valid = np.logical_and(nir_band != 0, swir_band != 0)\n    ndmi[valid] = (nir_band[valid] - swir_band[valid]) / (nir_band[valid] + swir_band[valid])\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the NDVI array to it\n    ndmi_path = os.path.join(tmp_dir.name, 'ndmi_composite.tif')\n    ndmi_ds = driver.Create(ndmi_path, xsize, ysize, 1, gdal.GDT_Float32)\n\n    if ndmi_ds is not None:\n        ndmi_ds.SetProjection(proj)\n        ndmi_ds.SetGeoTransform(geotrans)\n        ndmi_ds.GetRasterBand(1).WriteArray(ndmi)\n        ndmi_ds.FlushCache()\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return ndmi_path\n</code></pre>"},{"location":"bassmap/#bassmap.bassmap.get_truecolor","title":"<code>get_truecolor(red_band, green_band, blue_band, georef)</code>","text":"<p>Generate a true-color composite image from red, green, and blue bands.</p> <p>Parameters:</p> Name Type Description Default <code>red_band</code> <code>ndarray</code> <p>A 2D numpy array representing the red band.</p> required <code>green_band</code> <code>ndarray</code> <p>A 2D numpy array representing the green band.</p> required <code>blue_band</code> <code>ndarray</code> <p>A 2D numpy array representing the blue band.</p> required <code>georef</code> <code>osgeo.gdal.Dataset</code> <p>A GDAL dataset containing georeferencing information for the input bands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the created true color file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input arrays are not of the same shape.</p> <code>ValueError</code> <p>If the input arrays have different data types.</p> <code>ValueError</code> <p>If the input arrays have invalid values.</p> <code>ImportError</code> <p>If the GDAL library is not installed.</p> <p>Examples:</p>"},{"location":"bassmap/#bassmap.bassmap.get_truecolor--load-the-red-green-and-blue-bands-from-geotiff-files","title":"Load the red, green, and blue bands from GeoTIFF files","text":"<p>red_band = gdal.Open('path/to/red_band.tif').ReadAsArray() green_band = gdal.Open('path/to/green_band.tif').ReadAsArray() blue_band = gdal.Open('path/to/blue_band.tif').ReadAsArray() georef = gdal.Open('path/to/reference.tif')</p>"},{"location":"bassmap/#bassmap.bassmap.get_truecolor--generate-a-true-color-composite-image-and-download-it","title":"Generate a true-color composite image and download it","text":"<p>true_color_path = true_color_path(red_band, green_band, blue_band, georef)</p>"},{"location":"bassmap/#bassmap.bassmap.get_truecolor--download-the-file-at-true_color_path","title":"Download the file at true_color_path","text":"Source code in <code>bassmap/bassmap.py</code> <pre><code>def get_truecolor(red_band, green_band, blue_band, georef):\n\n\"\"\"Generate a true-color composite image from red, green, and blue bands.\n\n    Args:\n        red_band (ndarray): A 2D numpy array representing the red band.\n        green_band (ndarray): A 2D numpy array representing the green band.\n        blue_band (ndarray): A 2D numpy array representing the blue band.\n        georef (osgeo.gdal.Dataset): A GDAL dataset containing georeferencing information for the input bands.\n\n    Returns:\n        str: The path to the created true color file.\n\n    Raises:\n        ValueError: If the input arrays are not of the same shape.\n        ValueError: If the input arrays have different data types.\n        ValueError: If the input arrays have invalid values.\n        ImportError: If the GDAL library is not installed.\n\n    Example:\n        # Load the red, green, and blue bands from GeoTIFF files\n        red_band = gdal.Open('path/to/red_band.tif').ReadAsArray()\n        green_band = gdal.Open('path/to/green_band.tif').ReadAsArray()\n        blue_band = gdal.Open('path/to/blue_band.tif').ReadAsArray()\n        georef = gdal.Open('path/to/reference.tif')\n\n        # Generate a true-color composite image and download it\n        true_color_path = true_color_path(red_band, green_band, blue_band, georef)\n        # Download the file at true_color_path\n    \"\"\"\n\n    from osgeo import gdal\n\n    # Combine the three bands into a single 3D array with 3 bands\n    true_color = np.array([red_band, green_band, blue_band], dtype=np.uint16)\n\n    # Get the dimensions and georeferencing information from one of the input files\n    xsize = georef.RasterXSize\n    ysize = georef.RasterYSize\n    proj = georef.GetProjection()\n    geotrans = georef.GetGeoTransform()\n    driver = gdal.GetDriverByName('GTiff')\n\n    # Create a new TIFF file and write the NDVI array to it\n    true_color_path = os.path.join(tmp_dir.name, 'true_color_comp.tif')\n    true_color_ds = driver.Create(true_color_path, xsize, ysize, 3, gdal.GDT_Float32)\n\n    if true_color_ds is not None:\n        true_color_ds.SetProjection(proj)\n        true_color_ds.SetGeoTransform(geotrans)\n        true_color_ds.GetRasterBand(1).WriteArray(true_color[0])\n        true_color_ds.GetRasterBand(2).WriteArray(true_color[1])\n        true_color_ds.GetRasterBand(3).WriteArray(true_color[2])\n        true_color_ds.FlushCache()\n\n    else:\n        raise Exception(\"Failed to create TIFF file\")\n\n    return true_color_path\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"changelog/#v002-april-7-2023","title":"v0.0.2 - April 7, 2023","text":"<ul> <li>Added get_location_name function</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bassneel/bassmap/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>bassmap could always use more documentation, whether as part of the official bassmap docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bassneel/bassmap/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up bassmap for local development.</p> <ol> <li> <p>Fork the bassmap repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/bassmap.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv bassmap\n$ cd bassmap/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 bassmap tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/bassneel/bassmap/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install bassmap, run this command in your terminal:</p> <pre><code>pip install bassmap\n</code></pre> <p>This is the preferred method to install bassmap, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for bassmap can be downloaded from the Github repo.</p> <p>You can clone the public repository:</p> <pre><code>git clone git://github.com/bassneel/bassmap\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use bassmap in a project:</p> <pre><code>import bassmap\n</code></pre>"},{"location":"examples/Foliumatic/","title":"Foliumatic","text":"In\u00a0[1]: Copied! <pre>import bassmap\nfrom bassmap.Foliumatic import Foliumatic\n</pre> import bassmap from bassmap.Foliumatic import Foliumatic In\u00a0[2]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson'\nm = Foliumatic()\nm.add_vector(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson' m = Foliumatic() m.add_vector(url) m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson'\nm = Foliumatic()\nm.add_geojson(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson' m = Foliumatic() m.add_geojson(url) m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/world_countries.zip'\nm = Foliumatic()\nm.add_shp(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/world_countries.zip' m = Foliumatic() m.add_shp(url) m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[5]: Copied! <pre>m = Foliumatic()\nurl_template = 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png'\nm.add_basemap('OpenTopoMap', url_template)\nm\n</pre> m = Foliumatic() url_template = 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png' m.add_basemap('OpenTopoMap', url_template) m Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/Landsat_8_Tools/","title":"Landsat 8 Tools","text":"<p>notebook: <code>!pip install bassmap gdal</code></p> <p>conda env: <code>pip install bassmap</code> and <code>conda install -c conda-forge gdal</code></p> In\u00a0[\u00a0]: Copied! <pre># !pip install bassmap\n# !pip install gdal\n</pre> # !pip install bassmap # !pip install gdal <p>Import bassmap module</p> In\u00a0[1]: Copied! <pre>import bassmap\nfrom osgeo import gdal\n</pre> import bassmap from osgeo import gdal <p>Define file path to Landsat 8 GeoTIFF bands</p> In\u00a0[2]: Copied! <pre>### If using local file directory\n\nred_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF').ReadAsArray()\ngreen_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B3.TIF').ReadAsArray()\nblue_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B2.TIF').ReadAsArray()\nnir_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B5.TIF').ReadAsArray()\nswir_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B6.TIF').ReadAsArray()\nswir2_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B7.TIF').ReadAsArray()\ngeoref = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF')\n</pre> ### If using local file directory  red_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF').ReadAsArray() green_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B3.TIF').ReadAsArray() blue_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B2.TIF').ReadAsArray() nir_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B5.TIF').ReadAsArray() swir_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B6.TIF').ReadAsArray() swir2_band = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B7.TIF').ReadAsArray() georef = gdal.Open('C:/Users/bassn/temp_dir/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF') <p>If using Google Colab**</p> In\u00a0[6]: Copied! <pre># Uncomment to use in Google Colab\n\n# red_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF').ReadAsArray()\n# green_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B3.TIF').ReadAsArray()\n# blue_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B2.TIF').ReadAsArray()\n# nir_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B5.TIF').ReadAsArray()\n# swir_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B6.TIF').ReadAsArray()\n# swir2_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B7.TIF').ReadAsArray()\n# georef = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF')\n</pre> # Uncomment to use in Google Colab  # red_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF').ReadAsArray() # green_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B3.TIF').ReadAsArray() # blue_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B2.TIF').ReadAsArray() # nir_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B5.TIF').ReadAsArray() # swir_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B6.TIF').ReadAsArray() # swir2_band = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B7.TIF').ReadAsArray() # georef = gdal.Open('/content/LC09_L1TP_021035_20230419_20230420_02_T1_B4.TIF') In\u00a0[3]: Copied! <pre>from bassmap import get_truecolor\nget_truecolor(red_band, green_band, blue_band, georef)\n</pre> from bassmap import get_truecolor get_truecolor(red_band, green_band, blue_band, georef) Out[3]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\true_color_comp.tif'</pre> In\u00a0[4]: Copied! <pre>from bassmap import get_color_infrared\nget_color_infrared(nir_band, red_band, green_band, georef)\n</pre> from bassmap import get_color_infrared get_color_infrared(nir_band, red_band, green_band, georef) Out[4]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\color_infrared_comp.tif'</pre> In\u00a0[5]: Copied! <pre>from bassmap import get_false_color\nget_false_color(swir2_band, swir_band, red_band, georef)\n</pre> from bassmap import get_false_color get_false_color(swir2_band, swir_band, red_band, georef) Out[5]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\false_color_comp.tif'</pre> In\u00a0[6]: Copied! <pre>from bassmap import get_health_veg\nget_health_veg(nir_band, swir_band, blue_band, georef)\n</pre> from bassmap import get_health_veg get_health_veg(nir_band, swir_band, blue_band, georef) Out[6]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\healthy_veg_comp.tif'</pre> In\u00a0[7]: Copied! <pre>from bassmap import get_ndmi\nget_ndmi(nir_band, swir_band, georef)\n</pre> from bassmap import get_ndmi get_ndmi(nir_band, swir_band, georef) Out[7]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\ndmi_composite.tif'</pre> In\u00a0[8]: Copied! <pre>from bassmap import get_NDVI\nget_NDVI(red_band, nir_band, georef)\n</pre> from bassmap import get_NDVI get_NDVI(red_band, nir_band, georef) Out[8]: <pre>'C:\\\\Users\\\\bassn\\\\AppData\\\\Local\\\\Temp\\\\tmp94oux5ua\\\\ndvi_composite.tif'</pre>"},{"location":"examples/Landsat_8_Tools/#landsat-8-tools","title":"Landsat 8 Tools\u00b6","text":"<p>The following tools can be used to easily convert individual Landsat 8 bands into multispectral composites for use in remote sensing.</p>"},{"location":"examples/Landsat_8_Tools/#install-bassmap","title":"Install Bassmap\u00b6","text":"<p>Install Bassmap package to python notebook or conda environment. Make sure to install GDAL to your notebook or environment with:</p>"},{"location":"examples/Landsat_8_Tools/#remote-sensing-applications","title":"Remote Sensing Applications\u00b6","text":"<p>Using the following functions, you can create different spectral composites of Landsat 8 satellite data using local GeoTIFF files downloaded from USGS EarthExplorer.</p>"},{"location":"examples/Landsat_8_Tools/#get-true-color-composite","title":"Get True Color composite\u00b6","text":""},{"location":"examples/Landsat_8_Tools/#get-color-infrared-buildings-composite","title":"Get Color Infrared (Buildings) composite\u00b6","text":""},{"location":"examples/Landsat_8_Tools/#get-false-color-vegetation-composite","title":"Get False Color (Vegetation) composite\u00b6","text":""},{"location":"examples/Landsat_8_Tools/#get-healthy-vegetation-composite","title":"Get Healthy Vegetation composite\u00b6","text":""},{"location":"examples/Landsat_8_Tools/#get-normalized-difference-moisture-index-ndmi-composite","title":"Get Normalized Difference Moisture Index (NDMI) composite\u00b6","text":""},{"location":"examples/Landsat_8_Tools/#get-normalized-difference-vegetation-index-ndvi-composite","title":"Get Normalized Difference Vegetation Index (NDVI) composite\u00b6","text":""},{"location":"examples/Mapomatic/","title":"Mapomatic","text":"In\u00a0[1]: Copied! <pre>import bassmap\n</pre> import bassmap In\u00a0[2]: Copied! <pre>from bassmap import Mapomatic\n</pre> from bassmap import Mapomatic In\u00a0[3]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/world_countries.zip'\nm = Mapomatic(center=[0, 0], zoom=2)\nm.add_shp(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/world_countries.zip' m = Mapomatic(center=[0, 0], zoom=2) m.add_shp(url) m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre> In\u00a0[4]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson'\nm = Mapomatic(center=[0, 0], zoom=2)\nm.add_geojson(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson' m = Mapomatic(center=[0, 0], zoom=2) m.add_geojson(url) m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre> In\u00a0[5]: Copied! <pre>url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson'\nm = Mapomatic(center=[0, 0], zoom=2)\nm.add_vector(url)\nm\n</pre> url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/World_Countries_(Generalized).geojson' m = Mapomatic(center=[0, 0], zoom=2) m.add_vector(url) m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre> In\u00a0[6]: Copied! <pre>m = Mapomatic(center=[0, 0], zoom=2)\nm.add_basemap('OpenTopoMap', 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png')\nm\n</pre> m = Mapomatic(center=[0, 0], zoom=2) m.add_basemap('OpenTopoMap', 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png') m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre> In\u00a0[7]: Copied! <pre>m = Mapomatic(center=(0, 0), zoom=2)\nurl = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/bassmap_logo.png'\nposition = (0, 0)\nsize = (100, 100)\nm.add_image(url, position, size, opacity=0.7, layer_name='My Logo')\nm\n</pre> m = Mapomatic(center=(0, 0), zoom=2) url = 'https://raw.githubusercontent.com/bassneel/basspublicfiles/main/bassmap_logo.png' position = (0, 0) size = (100, 100) m.add_image(url, position, size, opacity=0.7, layer_name='My Logo') m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre> In\u00a0[8]: Copied! <pre>m = Mapomatic(center=(0, 0), zoom=2)\nurl = 'https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif'\nm.add_raster(url, cmap='terrain', opacity=0.7, layer_name='My COG')\nm\n</pre> m = Mapomatic(center=(0, 0), zoom=2) url = 'https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif' m.add_raster(url, cmap='terrain', opacity=0.7, layer_name='My COG') m <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre>"},{"location":"examples/select_basemap/","title":"Select basemap","text":"In\u00a0[1]: Copied! <pre>import bassmap\nfrom bassmap import Mapomatic\n</pre> import bassmap from bassmap import Mapomatic In\u00a0[2]: Copied! <pre>m = Mapomatic(center=[0, 0], zoom=2)\nm.select_basemap()\ndisplay(m)\n</pre> m = Mapomatic(center=[0, 0], zoom=2) m.select_basemap() display(m) <pre>Mapomatic(center=[0, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out\u2026</pre>"}]}